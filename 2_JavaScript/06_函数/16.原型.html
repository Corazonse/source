<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        /*
            原型prototype

            我们创建的每一个函数，解析器都会向函数添加一个属性 prototype
                这个属性对应着一个对象，这个对象就是所谓的原型对象（prototype指向的是原型对象的地址）
            如果作为普通的函数调用prototype没有任何作用
            当函数通过构造函数调用时，他所创建的对象中都用一个隐含的属性，
                指得是该构造函数的原型对象 （prototype指向的是原型对象的地址）.prototype ==.__proto__
                我可们可以通过__proto__来访问该属性。



                原型对象就相当于一个公共的区域，所有同一类的实例都可以访问到这个元神对象，
                    我们可以将对象中的公共内容，统一设置到原型对象中

                以后我们创建构造函数时，可以将这些对象公有的方法和属性，统一添加到函数的原型对象中，
                这样不用分别每一个对象添加，也不会一想到全局作用域，就可以使得每个对象都具有这些属性和方法了

        */
        function Person() {

        }

        //    向Peopled的原型对象中添加属性a
        Person.prototype.a = 123;
        Person.prototype.sayHello = "你好";
        var p1 = new Person();
        var p2 = new Person();
        var p3 = new Person();//他们指向的是同一个一个原型对象
        //    指向元向对象
        console.log(Person.prototype == p1.__proto__);//p1 p2 p3 都是true
        console.log(p1.a);//当访问对象的属性或者方法时  他先回在我们对象的自身中寻找，如果有就
        // 直接使用冰返回 如果没有则会直接去原型对象中寻找 如果有就会直接返回
        console.log(p2.sayHello)

    </script>
</head>
<body>

</body>
</html>